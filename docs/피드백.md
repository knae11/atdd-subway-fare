# 피드백

1. 클래스 단위의 `@Transactional` 사용
- 저는 개인적으로 클래스 레벨에 Transactional을 사용하는 것을 선호하지 않습니다
  트랜잭션은 굉장히 비용이 큰 작업이고, 불필요한 트랜잭션으로 성능이 낮아지는 문제도 있지만 더 큰 문제는 의도되지 않은 트랜잭션으로 인해 데드락이 발생할 수 있다 라는 것이 생각입니다
  실제 현업에서 대규모 트래픽을 처리하기 위해 데드락이 발생하지 않도록 설계하는 것이 굉장히 중요한데요
  개발하는 과정에서도 이 기능에 데드락이 발생할 요소가 있을까? 트랜잭션을 꼭 잡아야 가능한 기능일까? 구조를 변경하여 락이 필요 없는 구조로 바꿀 수 없을까? 에 대해 끊임없이 고민하게 되는데, 이러한 고민을 하는 시점이 저는 메서드에 Transactional 처리를 하는 시점에 가장 많이 하는 것 같습니다
  
  또한 클래스마다 트랜잭션과 격리레벨이 정해지는 것이 아닌 기능(메서드)단위로 처리되기 때문에 클래스에 적용하여 공통으로 처리할 필요가 있을까? 라는 의문이 들었습니다 ㅎㅎ

2. Q1. 요금 관련해서 로그인 사용자와 비로그인 사용자도 모두 접근 가능하게 해야 하더라구요. 이때, 방법을 잘 몰라서 지금은 null로 보내주고 null인지 체크를 하게 만들었는데ㅠㅠ null을 보내주는게 마음에 조금 걸려서요. Service 단에서 로그인 여부를 체크해서 다른 메소드를 불러주게 되어 있어서 null 자체를 넘길 수 밖에 없었어요. 나이 정보 때문에 이렇게 구성하게 되었는데, 혹시 더 좋은 방법이 있을지 궁금합니다.

- A1. 하나의 메서드에서 로그인에 따라 다르게 처리될 경우 지금과 같은 분리처리는 어쩔 수 없을 것 같습니다 T.T
Null Check 자체가 로그인을 확인하는 것이 명시적이지 않은 것이 문제라면, isLogin과 같은 기능을 추상화하여 로그인한 유저와 로그인하지 않은 유저로 나누어 처리할 수 있는 방법이 있을 것 같습니다
(혹은 Role에 대한 역할을 추가해봐도 되겠네요!!)

  이러한 처리는 일종의 Null Object Pattern과 같은 개념으로 해당 키워드로 검색해보면 좋을 것 같아요 ㅎㅎ

  조금 더 나아가서 API 설계 시, 누구나 접근할 수 있는 API와 로그인 한 유저만 접근할 수 있는 API 2개로 나누어 클라이언트에서 분기처리 하는 방법도 있답니다 :)

3. Q2. 지금 lines/{id}, lines/{id}/sections/~~ 이런식으로 체크하다 보니 lines와 관련된 모든 로직은 lineId에 대한 검증로직을 추가해주어야 하더라구요. 모든 곳에 중복되서 validate 가 들어가는데 혹시 더 개선하는 방향이 있나요? 아니면 보통 이렇게 매 메소드 호출시 Service 단에서 중복 검증로직을 추가해주는 편인가요?

- A2. line과 연관이 있는 부분이라면 같이 검증을 해주셔야 할 것 같습니다!
방법은 lineId와 sectionId를 같이 조회하는 방식 등으로 처리될 수도 있고, 다른 로직이 있을 수도 있을 것 같습니다 :)

# todos
- [x] 클래스 단위의 `@Transactional` 공부
- [x] 데드락 공부 -> DB와 데드락 더 공부해보기
- [x] 메서드 명 반환값(return)과 연관지어 다시 확인하기
- [x] `@Bean`, `@Component` 등록 차이는?
- [ ] 인터셉터가 설정이 가지는 의미와 `/path`?
- [x] 예외처리 구조확인, handle
- [x] Distance 클래스?
- [x] 인수턴스 변수 초기화를 하나의 생성자로?
- [x] SectionResponse 정적팩토리메서드 명 수정
- [x] MemberService -> isPresent 로 끊어보기 (가독성 향상)
- [x] Fare 도메인에 대한 추상화(내용 추가시에도 코드 수정 안 할 수 있게)
- [ ] `@nested` 테스트 공부
