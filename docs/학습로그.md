# 학습로그

# [DB] 트랜잭션
## 데드락
- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
- [참고링크 - 데이터베이스에서 데드락](https://myjamong.tistory.com/181)
- 내용은 read 에도 transactional 을 걸어버리면 모든 것에 lock 이 걸리게 됨
- read 와 자료수정이 같이 일어나면, lock 되어 있는 상태에서 데드락이 발생할 가능성이 있는 것 같음
- 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있는 현상
- [참고링크](https://mangkyu.tistory.com/30)
- 한 테이블에서 순서없이 갱신하면 교착상태가 발생하기 쉽다. 갱신을 직렬화하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

## 격리수준(isolation level)
- `@Transactional`에 걸리는 격리수준의 기본설정은 DB의 기본 설정을 따른다.
- READ_UNCOMMITTED: 가장 낮은 수준의 격리수준
- READ_COMMITTED: dirty read 를 막아줌. commit 된 내용만 read 가능(트랜잭션 시, 다른 부분이 커밋되면 변경된 내용으로 읽기 가능)
- REPEATABLE_READ: 세번째 수준의 격리수준. 처음 읽기 시작할 시점의 커밋된 내용만 read 가능
- SERIALIZABLE: 가장 높은 격리수준으로 read에도 lock을 생성

## 전파속성(propagation)
- 이제 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성
- REQUIRED: default. 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 새로운 트랜잭션을 발생
- SUPPORTS: 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 트랜잭션 없이 진행
- MANDATORY: 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 예외를 발생
- NEVER: 활성된 트랜잭션이 있다면 예외를 발생
- NOT_SUPPORTED: 활성된 트랜잭션이 있다면 보류시킴
- REQUIRES_NEW: 활성된 트랜잭션이 있다면 보류시키고 새 트랜잭션을 생성
- NESTED: 이미 진행중인 트랜잭션이 있다면, save point 를 마크함. 그리고 중첩 트랜잭션을 실행
- [propagation - bealdung blog](https://www.baeldung.com/spring-transactional-propagation-isolation)

## 태그
- DB, 트랜잭션, 데드락
