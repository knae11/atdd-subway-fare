# 학습로그

# [DB] 트랜잭션
## 데드락
- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
- [참고링크 - 데이터베이스에서 데드락](https://myjamong.tistory.com/181)
- 락이 걸려있는 것들 끼리 자료수정이 같이 일어나면, lock 되어 있는 상태에서 데드락이 발생할 가능성이 있는 것 같음
- 격리수준이 높을 수록 락의 가능성이 높아짐?!
- 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있는 현상
- [참고링크](https://mangkyu.tistory.com/30)
- 한 테이블에서 순서없이 갱신하면 교착상태가 발생하기 쉽다. 갱신을 직렬화하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

## 격리수준(isolation level)
- `@Transactional`에 걸리는 격리수준의 기본설정은 DB의 기본 설정을 따른다.
- READ_UNCOMMITTED: 가장 낮은 수준의 격리수준
- READ_COMMITTED: dirty read 를 막아줌. commit 된 내용만 read 가능(트랜잭션 시, 다른 부분이 커밋되면 변경된 내용으로 읽기 가능)
- REPEATABLE_READ: 세번째 수준의 격리수준. 처음 읽기 시작할 시점의 커밋된 내용만 read 가능
- SERIALIZABLE: 가장 높은 격리수준으로 read에도 lock을 생성

## 전파속성(propagation)
- 이제 트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성
- REQUIRED: default. 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 새로운 트랜잭션을 발생
- SUPPORTS: 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 트랜잭션 없이 진행
- MANDATORY: 활성된 트랜잭션이 있다면 참여하고, 그렇지 않다면 예외를 발생
- NEVER: 활성된 트랜잭션이 있다면 예외를 발생
- NOT_SUPPORTED: 활성된 트랜잭션이 있다면 보류시킴
- REQUIRES_NEW: 활성된 트랜잭션이 있다면 보류시키고 새 트랜잭션을 생성
- NESTED: 이미 진행중인 트랜잭션이 있다면, save point 를 마크함. 그리고 중첩 트랜잭션을 실행
- [propagation - bealdung blog](https://www.baeldung.com/spring-transactional-propagation-isolation)

## 태그
- DB, 트랜잭션, 데드락

# [Spring] `@Bean`, `@Component`
## `@Bean` VS `@Component`
- `@Bean`
    - 외부 라이브러리들을 Bean 으로 등록하고 싶은 경우에 사용
    - 메소드 단위, 어노테이션 단위에 붙일 수 있음, 클래스 단위는 불가함
    - 인스턴스를 생성하는 메소드를 만들고 해당 메소드에 `@Bean`을 선언하여 Bean 으로 등록
    - `@Bean`은 `@Configuration`이 붙은 DI 설정용 클래스에서 주로 사용하는 것으로, 메소드를 이용해서 빈 오브젝트의 생성과 의존관계 주입을 직접 자바코드르 작성
    - `@Configuration` 자바 클래스에서 정의한 빈과 XML 에서 정의한 빈은 얼마든지 서로 참조가 가능 
    - 스캔할 필요 없이 빈 등록이 빠르게 이루어짐
    - [스프링 공식문서 Bean](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts)
- `@Component`
    - 개발자가 직접 컨트롤이 가능한 Class 들의 경우
    - 빈으로 등록될 후보 클래스에 붙여주는 일종의 마커
    - `@Component`가 있는 클래스를 찾아서 빈으로 등록하려면 빈 스캔 기능을 사용하겠다는 어노테이션 정의가 필요
    - 컴포넌트 어노테이션이 있는 클래스를 찾아서 빈으로 등록하는 건 부담가는 작업
    - 특정 패키지 아래서만 찾도록 기준이 되는 패키지를 지정하는 것이 좋음 -> `@ComponentScan`을 사용
    - `@Autowired`로 찾을 대상이 두 개 이상인 경우(같은 타입의 빈이 두개 이상인 경우), 이름을 기준으로 빈을 등록해야하기 때문에 빈의 아이디가 중요해짐
    - 이럴때, 클래스 이름 대신 빈의 아이디로 사용하고 싶다면 `@Component("userDao")`처럼 애노테이션에 이름을 넣어주면 됨 (토비의 스프링:678pg)
    - [스프링 공식문서 Component](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-stereotype-annotations)
    - `@Configuration`도 `@Bean`이다.
  
- 둘 간의 큰 성능차이는 없는 것 같다. Bean 으로 등록하는 방식이 더 오래된 방식 같으며, 외부 라이브러리에는 `@Component`를 사용할 수 없어 인스턴스를 만들어 `@Bean`으로 등록
- [bean, component](https://jojoldu.tistory.com/27)
- 토비의 스프링 7장
## `@Resource` VS `@Autowired`
- 빈 등록
- `@Autowired`: 필드의 타입으로 기준으로 빈을 찾음
- `@Resource`: 필드의 이름 기준으로 빈을 찾음

## 태그
- 빈 등록

